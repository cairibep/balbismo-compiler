/// Abstract Syntax Tree (AST) parsing utilities for the Balbismo compiler.
///
/// This library provides functionality to parse YAML representations of abstract
/// syntax trees into concrete AST node objects. The parser handles the conversion
/// from the intermediate YAML format (generated by the flex-bison parser) into
/// the object-oriented AST representation used by the compiler.
///
/// The YAML format represents the parsed source code structure, including:
/// - Language constructs (functions, variables, expressions)
/// - Type information and declarations
/// - Control flow structures (if, while, etc.)
/// - Operator expressions and literals
///
/// This parser is essential for bridging the lexical/syntax analysis phase
/// with the semantic analysis and code generation phases of compilation.

import 'dart:io';

import 'package:balbismo/node.dart';
import 'package:balbismo/vars.dart';
import 'package:yaml/yaml.dart';

/// Parses an AST file from YAML format into a concrete AST node structure.
///
/// This function serves as the main entry point for AST parsing. It reads a YAML
/// file containing the abstract syntax tree representation (typically generated
/// by the flex-bison parser) and converts it into a tree of [Node] objects that
/// can be processed by the semantic analyzer and code generator.
///
/// The YAML file format contains structured representations of:
/// - Program statements and declarations
/// - Expression trees with operator precedence
/// - Type information and variable declarations
/// - Function definitions and calls
/// - Control flow constructs
///
/// Parameters:
/// - [path]: File system path to the YAML AST file
///
/// Returns:
///   The root [Node] of the parsed AST
///
/// Throws:
/// - [FileSystemException] if the file cannot be read
/// - [YamlException] if the YAML format is invalid
/// - [Exception] if the AST structure contains unsupported node types
///
/// Example:
/// ```dart
/// final ast = parseAstFile("build/tmp/ast.out");
/// ast.evaluate(SymbolTable()); // Process the AST
/// ```
Node parseAstFile(String path) {
  var yamlString = File(path).readAsStringSync();
  YamlMap astDict = loadYaml(yamlString)[0];
  return parseNode(astDict);
}

/// Recursively parses a YAML node representation into a concrete AST node.
///
/// This function is the core of the AST parsing system. It takes a YAML map
/// representing a single AST node and converts it into the appropriate [Node]
/// subclass based on the node type. The function handles the recursive nature
/// of AST structures by parsing child nodes and assembling them into the
/// appropriate parent node structure.
///
/// The parsing process involves:
/// 1. Extracting the node type from the YAML structure
/// 2. Recursively parsing all child nodes
/// 3. Extracting node-specific values (literals, identifiers, etc.)
/// 4. Constructing the appropriate [Node] subclass with correct parameters
///
/// Parameters:
/// - [node]: YAML map containing the node representation with 'type', 'value',
///   and 'children' fields
///
/// Returns:
///   A concrete [Node] instance of the appropriate subclass
///
/// Throws:
/// - [Exception] if the node type is not recognized or supported
/// - Various exceptions from individual node constructors if parameters are invalid
///
/// Supported node types include:
/// - Block, Identifier, Type, ArrayType, Declaration, Assignment
/// - Binary/unary operations, literals, function calls
/// - Control flow (If, While), I/O operations (Print, Scanf)
/// - Type casting and string handling
Node parseNode(YamlMap node) {
  var type = node["type"];
  var childrenDict = node["children"];
  final children = <Node>[];
  if (childrenDict != null) {
    for (var child in childrenDict) {
      children.add(parseNode(child));
    }
  }
  final value = node["value"];
  switch (type) {
    case "Block":
      return BlockNode(children);
    case "Identifier":
      return IdentifierNode(value);
    case "IndexedIdentifier":
      return IndexedIdentifierNode(
        value,
        children[0] as Node<dynamic, LangVal>,
      );
    case "Type":
      return TypeNode(PrimitiveType(PrimitiveTypes.fromString(value)));
    case "ArrayType":
      return ArrayTypeNode(
        children[0] as TypeNode,
        children[1] as ArraySpecification,
      );
    case "ArraySpecifier":
      return ArraySpecification(
        children.firstOrNull as Node<dynamic, LangVal>?,
      );
    case "IntLiteral":
      return IntVal(value);
    case "FloatLiteral":
      return FloatVal(value);
    case "Declaration":
      return DeclareNode(
        children[0] as Node<LangType, dynamic>,
        children[1] as IdentifierNode,
        children.length > 2 ? children[2] : null,
      );
    case "Assignment":
      return AssignmentNode(children[0] as IdentifierNode, children[1]);
    case "UnOp":
      return UnOp(value, children[0] as Node<dynamic, LangVal>);
    case "BinOp":
      return BinOp(
        value,
        children[0] as Node<dynamic, LangVal>,
        children[1] as Node<dynamic, LangVal>,
      );
    case "Print":
      return PrintNode(
        children[0] as StringLiteral,
        children.sublist(1).cast(),
      );
    case "RelOp":
      return RelOp(
        value,
        children[0] as Node<dynamic, LangVal>,
        children[1] as Node<dynamic, LangVal>,
      );
    case "BoolUnOp":
      return BoolUnOp(value, children[0] as Node<dynamic, LangVal>);
    case "BoolBinOp":
      return BoolBinOp(
        value,
        children[0] as Node<dynamic, LangVal>,
        children[1] as Node<dynamic, LangVal>,
      );
    case "IfStatement":
      return IfNode(
        children[0] as Node<dynamic, LangVal>,
        children[1] as BlockNode,
        children.length > 2 ? children[2] : null,
      );
    case "WhileStatement":
      return WhileNode(
        children[0] as Node<dynamic, LangVal>,
        children[1] as BlockNode,
      );
    case "ParameterList":
      return ParameterList(children.cast());
    case "ArgumentList":
      return ArgumentList(children.cast());
    case "FunctionDeclaration":
      return FuncDec(
        children[0] as TypeNode,
        children[1] as IdentifierNode,
        children[2] as ParameterList,
        children[3] as BlockNode,
      );
    case "FunctionCall":
      return FuncCall(
        children[0] as IdentifierNode,
        children[1] as ArgumentList,
      );
    case "ReturnStatement":
      return ReturnStatement(children[0] as Node<dynamic, LangVal>);
    case "FunctionList":
      return FunctionList(children.cast());
    case "TypeCast":
      return TypeCast(
        PrimitiveType(PrimitiveTypes.fromString(value)),
        children[0] as Node<dynamic, LangVal>,
      );
    case "StringLiteral":
      return StringLiteral(value);
    case "Scanf":
      return ScanfNode(
        children[0] as StringLiteral,
        children.sublist(1).cast(),
      );
    default:
      throw Exception("Unknown node type: $type");
  }
}
